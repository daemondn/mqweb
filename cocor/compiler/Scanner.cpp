/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
#include <iostream>

#include <memory.h>
#include "Scanner.h"

namespace Coco {


Token::Token() {
	kind = 0;
	pos  = 0;
	col  = 0;
	line = 0;
}

Token::~Token() {
}


Scanner::Scanner(std::istream& in) : buffer(in)
{
  Init();
}

Scanner::~Scanner() 
{
	//delete buffer;
}

void Scanner::Init() {
	EOL    = '\n';
	eofSym = 0;
	maxT = 41;
	noSym = 41;
	int i;
  for (i = 65; i <= 90; ++i) start.insert(std::make_pair<int, int>(i, 1));
	for (i = 95; i <= 95; ++i) start.insert(std::make_pair<int, int>(i, 1));
	for (i = 97; i <= 122; ++i) start.insert(std::make_pair<int, int>(i, 1));
	for (i = 48; i <= 57; ++i) start.insert(std::make_pair<int, int>(i, 2));
	start.insert(std::make_pair<int, int>(34, 12));
	start.insert(std::make_pair<int, int>(39, 5));
	start.insert(std::make_pair<int, int>(36, 13));
	start.insert(std::make_pair<int, int>(61, 16));
	start.insert(std::make_pair<int, int>(46, 31));
	start.insert(std::make_pair<int, int>(43, 17));
	start.insert(std::make_pair<int, int>(45, 18));
	start.insert(std::make_pair<int, int>(60, 32));
	start.insert(std::make_pair<int, int>(62, 20));
	start.insert(std::make_pair<int, int>(124, 23));
	start.insert(std::make_pair<int, int>(40, 33));
	start.insert(std::make_pair<int, int>(41, 24));
	start.insert(std::make_pair<int, int>(91, 25));
	start.insert(std::make_pair<int, int>(93, 26));
	start.insert(std::make_pair<int, int>(123, 27));
	start.insert(std::make_pair<int, int>(125, 28));
	//start.insert(std::make_pair<int, int>(Buffer::EoF, -1));
	start.insert(std::make_pair<int, int>(-1, -1));
  keywords.insert(std::pair<std::string, int>("COMPILER", 6));
	keywords.insert(std::pair<std::string, int>("IGNORECASE", 7));
	keywords.insert(std::pair<std::string, int>("CHARACTERS", 8));
	keywords.insert(std::pair<std::string, int>("TOKENS", 9));
	keywords.insert(std::pair<std::string, int>("PRAGMAS", 10));
	keywords.insert(std::pair<std::string, int>("COMMENTS", 11));
	keywords.insert(std::pair<std::string, int>("FROM", 12));
	keywords.insert(std::pair<std::string, int>("TO", 13));
	keywords.insert(std::pair<std::string, int>("NESTED", 14));
	keywords.insert(std::pair<std::string, int>("IGNORE", 15));
	keywords.insert(std::pair<std::string, int>("PRODUCTIONS", 16));
	keywords.insert(std::pair<std::string, int>("END", 19));
	keywords.insert(std::pair<std::string, int>("ANY", 23));
	keywords.insert(std::pair<std::string, int>("WEAK", 29));
	keywords.insert(std::pair<std::string, int>("SYNC", 36));
	keywords.insert(std::pair<std::string, int>("IF", 37));
	keywords.insert(std::pair<std::string, int>("CONTEXT", 38));


  tval.clear(); // text of current token

	pos = -1; line = 1; col = 0; charPos = -1;
	oldEols = 0;
	NextCh();
	if (ch == 0xEF) { // check optional byte order mark for UTF-8
		NextCh(); int ch1 = ch;
		NextCh(); int ch2 = ch;
		if (ch1 != 0xBB || ch2 != 0xBF) {
      std::cout << "Illegal byte order mark at start of file" << std::endl;
			exit(1);
		}
		NextCh();
	}

  pt = tokens.begin();
}

void Scanner::NextCh() {
	if (oldEols > 0) { ch = EOL; oldEols--; }
	else {
		pos = buffer.tellg();
		// buffer reads unicode chars, if UTF8 has been detected
		ch = buffer.get(); col++; charPos++;
		// replace isolated '\r' by '\n' in order to make
		// eol handling uniform across Windows, Unix and Mac
		if (ch == '\r' && buffer.peek() != '\n') ch = EOL;
		if (ch == EOL) { line++; col = 0; }
	}
}

void Scanner::AddCh() {
  if (ch != (COCO_WCHAR_MAX + 1)) 
  {
		tval += (char) ch;
    tlen++;
		NextCh();
	}
}


bool Scanner::Comment0() {
	int level = 1, pos0 = pos, line0 = line, col0 = col, charPos0 = charPos;
	NextCh();
	if (ch == '/') {
		NextCh();
		for(;;) {
			if (ch == 10) {
				level--;
				if (level == 0) { oldEols = line - line0; NextCh(); return true; }
				NextCh();
			} else if (ch == (COCO_WCHAR_MAX + 1) /*buffer->EoF*/) return false;
			else NextCh();
		}
	} else {
		//buffer->SetPos(pos0); NextCh(); line = line0; col = col0; charPos = charPos0;
    buffer.seekg(pos0, std::ios::beg); NextCh(); line = line0; col = col0; charPos = charPos0;
	}
	return false;
}

bool Scanner::Comment1() {
	int level = 1, pos0 = pos, line0 = line, col0 = col, charPos0 = charPos;
	NextCh();
	if (ch == '*') {
		NextCh();
		for(;;) {
			if (ch == '*') {
				NextCh();
				if (ch == '/') {
					level--;
					if (level == 0) { oldEols = line - line0; NextCh(); return true; }
					NextCh();
				}
			} else if (ch == '/') {
				NextCh();
				if (ch == '*') {
					level++; NextCh();
				}
			} else if (ch == (COCO_WCHAR_MAX + 1)/*buffer->EoF*/) return false;
			else NextCh();
		}
	} else {
		//buffer->SetPos(pos0); NextCh(); line = line0; col = col0; charPos = charPos0;
    buffer.seekg(pos0, std::ios::beg); NextCh(); line = line0; col = col0; charPos = charPos0;
	}
	return false;
}


Token* Scanner::CreateToken() 
{
	Token *t = new Token();
  tokens.push_back(t);
	return t;
}

Token* Scanner::NextToken() 
{
  tval.clear();

	while (ch == ' ' ||
			(ch >= 9 && ch <= 10) || ch == 13
	) NextCh();
	if ((ch == '/' && Comment0()) || (ch == '/' && Comment1())) return NextToken();
	int recKind = noSym;
	int recEnd = pos;
	t = CreateToken();
	t->pos = pos; t->col = col; t->line = line; t->charPos = charPos;
	int state = getStartState(ch);
	tlen = 0; AddCh();

	switch (state) {
		case -1: { t->kind = eofSym; break; } // NextCh already done
		case 0: {
			case_0:
			if (recKind != noSym) {
				tlen = recEnd - t->pos;
				SetScannerBehindT();
			}
			t->kind = recKind; break;
		} // NextCh already done
		case 1:
			case_1:
			recEnd = pos; recKind = 1;
			if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z')) {AddCh(); goto case_1;}
      else {t->kind = 1; t->kind = getKeywordIdentifier(tval, t->kind); break;}
		case 2:
			case_2:
			recEnd = pos; recKind = 2;
			if ((ch >= '0' && ch <= '9')) {AddCh(); goto case_2;}
			else {t->kind = 2; break;}
		case 3:
			case_3:
			{t->kind = 3; break;}
		case 4:
			case_4:
			{t->kind = 4; break;}
		case 5:
			if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '&') || (ch >= '(' && ch <= '[') || (ch >= ']' && ch <= 65535)) {AddCh(); goto case_6;}
			else if (ch == 92) {AddCh(); goto case_7;}
			else {goto case_0;}
		case 6:
			case_6:
			if (ch == 39) {AddCh(); goto case_9;}
			else {goto case_0;}
		case 7:
			case_7:
			if ((ch >= ' ' && ch <= '~')) {AddCh(); goto case_8;}
			else {goto case_0;}
		case 8:
			case_8:
			if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f')) {AddCh(); goto case_8;}
			else if (ch == 39) {AddCh(); goto case_9;}
			else {goto case_0;}
		case 9:
			case_9:
			{t->kind = 5; break;}
		case 10:
			case_10:
			recEnd = pos; recKind = 42;
			if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z')) {AddCh(); goto case_10;}
			else {t->kind = 42; break;}
		case 11:
			case_11:
			recEnd = pos; recKind = 43;
			if ((ch >= '-' && ch <= '.') || (ch >= '0' && ch <= ':') || (ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z')) {AddCh(); goto case_11;}
			else {t->kind = 43; break;}
		case 12:
			case_12:
			if (ch <= 9 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= '!') || (ch >= '#' && ch <= '[') || (ch >= ']' && ch <= 65535)) {AddCh(); goto case_12;}
			else if (ch == 10 || ch == 13) {AddCh(); goto case_4;}
			else if (ch == '"') {AddCh(); goto case_3;}
			else if (ch == 92) {AddCh(); goto case_14;}
			else {goto case_0;}
		case 13:
			recEnd = pos; recKind = 42;
			if ((ch >= '0' && ch <= '9')) {AddCh(); goto case_10;}
			else if ((ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z')) {AddCh(); goto case_15;}
			else {t->kind = 42; break;}
		case 14:
			case_14:
			if ((ch >= ' ' && ch <= '~')) {AddCh(); goto case_12;}
			else {goto case_0;}
		case 15:
			case_15:
			recEnd = pos; recKind = 42;
			if ((ch >= '0' && ch <= '9')) {AddCh(); goto case_10;}
			else if ((ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= 'a' && ch <= 'z')) {AddCh(); goto case_15;}
			else if (ch == '=') {AddCh(); goto case_11;}
			else {t->kind = 42; break;}
		case 16:
			{t->kind = 17; break;}
		case 17:
			{t->kind = 20; break;}
		case 18:
			{t->kind = 21; break;}
		case 19:
			case_19:
			{t->kind = 22; break;}
		case 20:
			{t->kind = 25; break;}
		case 21:
			case_21:
			{t->kind = 26; break;}
		case 22:
			case_22:
			{t->kind = 27; break;}
		case 23:
			{t->kind = 28; break;}
		case 24:
			{t->kind = 31; break;}
		case 25:
			{t->kind = 32; break;}
		case 26:
			{t->kind = 33; break;}
		case 27:
			{t->kind = 34; break;}
		case 28:
			{t->kind = 35; break;}
		case 29:
			case_29:
			{t->kind = 39; break;}
		case 30:
			case_30:
			{t->kind = 40; break;}
		case 31:
			recEnd = pos; recKind = 18;
			if (ch == '.') {AddCh(); goto case_19;}
			else if (ch == '>') {AddCh(); goto case_22;}
			else if (ch == ')') {AddCh(); goto case_30;}
			else {t->kind = 18; break;}
		case 32:
			recEnd = pos; recKind = 24;
			if (ch == '.') {AddCh(); goto case_21;}
			else {t->kind = 24; break;}
		case 33:
			recEnd = pos; recKind = 30;
			if (ch == '.') {AddCh(); goto case_29;}
			else {t->kind = 30; break;}

	}
  t->val = tval;
	return t;
}

void Scanner::SetScannerBehindT() {
  buffer.seekg(t->pos, std::ios::beg);
	NextCh();
	line = t->line; col = t->col; charPos = t->charPos;
	for (int i = 0; i < tlen; i++) NextCh();
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan() 
{
  if ( pt == tokens.end() ) 
  {
		Token* t = NextToken();
    pt = tokens.end();
    return t;
	} 

  Token *t = *pt;
  pt++;
	return t;
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek() {
	do 
  {
		if (pt == tokens.end() ) 
    {
			NextToken();
		}
		pt++;
	} while ((*pt)->kind > maxT); // skip pragmas

	return *pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek() 
{
	pt = tokens.begin();
}

int Scanner::getKeywordIdentifier(const std::string &keyword, int def) const
{
  KeywordMap::ConstIterator it = keywords.find(keyword);
  if ( it == keywords.end() )
  {
    return def;
  }
  return it->second;
}

int Scanner::getStartState(int key) const
{
	StartStates::ConstIterator it = start.find(key);
	if ( it == start.end() )
	{
		return 0;
  }
  return it->second;
}

} // namespace

