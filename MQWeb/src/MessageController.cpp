/*
 * Copyright 2010 MQWeb - Franky Braem
 *
 * Licensed under the EUPL, Version 1.1 or â€“ as soon they
 * will be approved by the European Commission - subsequent
 * versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
 * Licence.
 * You may obtain a copy of the Licence at:
 *
 * http://joinup.ec.europa.eu/software/page/eupl
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 */
#include <iostream>
#include <sstream>
#include <iomanip>

#include <MQ/Buffer.h>

#include <Poco/DateTimeFormatter.h>
#include <Poco/Net/HTMLForm.h>
#include <Poco/URI.h>
#include <Poco/Logger.h>
#include <Poco/HexBinaryEncoder.h>

#include <Poco/JSON/TemplateCache.h>

#include <MQ/MQException.h>
#include <MQ/Web/MessageController.h>
#include <MQ/Message.h>
#include <MQ/QueueManager.h>
#include <MQ/Queue.h>

/*
static  unsigned char
	EBCDIC_translate_ASCII[256] =
	{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
		0x2E, 0x2E, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x2E, 0x3F,
		0x20, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
		0x26, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
		0x2D, 0x2F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x7C, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
		0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
		0x2E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x2E, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x2E, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x2E, 0x2E, 0x2E, 0x5B, 0x2E, 0x2E,
		0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x5D, 0x2E, 0x2E,
		0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x5C, 0x2E, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E 
	};
*/
static unsigned char EBCDIC_translate_ASCII[256] =
{
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2F,
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x20, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
	0x26, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
	0x2D, 0x2F, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x7C, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
	0x2E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x2E, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x2E, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x2E, 0x2E, 0x2E, 0x5B, 0x2E, 0x2E,
	0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x5D, 0x2E, 0x2E,
	0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x5C, 0x2E, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E, 0x2E 
};

namespace MQ {
namespace Web {

MessageController::MessageController(Poco::Net::HTTPServerRequest& request, Poco::Net::HTTPServerResponse& response)
	: Controller(request, response)
{
}


MessageController::~MessageController()
{

}


void MessageController::handle()
{
	Poco::URI uri(_request.getURI());
	std::vector<std::string> paths;
	uri.getPathSegments(paths);

	if ( paths.size() < 5 )
	{
		_response.setStatus(Poco::Net::HTTPResponse::HTTP_BAD_REQUEST);
		return;
	}

	std::string queueName = paths[2];
	std::string messageId = paths[4];

	Buffer id(MQ_MSG_ID_LENGTH);
	for(int i = 0; i < MQ_MSG_ID_LENGTH; i++)
	{
		std::stringstream ss;
		int val;
		ss << std::setbase(16) << "0x" << messageId.substr(i * 2, 2);
		ss >> val;
		id[i] = (unsigned char) val;
	}

	Message message;
	message.setMessageId(id);

	Queue q(_qmgr, queueName);
	q.open(MQOO_BROWSE);

	try
	{
		//message.setCodedCharSetId(1208);
		q.get(message, MQGMO_BROWSE_FIRST /*| MQGMO_CONVERT*/);
	}
	catch(MQException mqe)
	{
		if ( mqe.reason()   == MQRC_TRUNCATED_MSG_FAILED
			|| mqe.reason() == MQRC_TRUNCATED )
		{
			//message.setCodedCharSetId(1208);
			message.buffer().resize(message.dataLength());
			q.get(message, MQGMO_BROWSE_FIRST /*| MQGMO_CONVERT*/);
		}
		else
		{
			throw;
		}
	}
	message.buffer().resize(message.dataLength());

	Poco::Net::HTMLForm form(_request);
	std::string type = form.get("type", "detail");

	Poco::JSON::Template::Ptr tpl;

	Poco::JSON::Object::Ptr jsonMessage = new Poco::JSON::Object();

	if ( type.compare("hex") == 0 )
	{
		Poco::JSON::Array::Ptr jsonDump = new Poco::JSON::Array();
		jsonMessage->set("dump", jsonDump);

		std::ostringstream oss;
		Poco::HexBinaryEncoder hexEncoder(oss);
		hexEncoder.rdbuf()->setLineLength(0);
		hexEncoder.rdbuf()->setUppercase(true);
		hexEncoder.write((const char*) &message.buffer()[0], message.buffer().size());

		std::string fullHex = oss.str();
		Poco::JSON::Object::Ptr jsonMessageDump = new Poco::JSON::Object();
		jsonMessageDump->set("position", "00000000");
		jsonDump->add(jsonMessageDump);

		std::string hexPart;
		for(int i = 0; i < fullHex.length(); ++i)
		{
			if ( i && i % 2 == 0 && i % 16 != 0 )
			{
				hexPart += ' ';
			}

			if ( i && i % 16 == 0 && i % 32 != 0 )
			{
				hexPart += "--";
			}

			if ( i && i % 32 == 0 )
			{
				jsonMessageDump->set("hex", hexPart);
				hexPart.clear();
				
				jsonMessageDump = new Poco::JSON::Object();
				std::ostringstream outputPos;
				outputPos << std::uppercase << std::right << std::setw(8) << std::setfill('0') << std::setbase(16) << (i / 2);
				jsonMessageDump->set("position", outputPos.str());
				jsonDump->add(jsonMessageDump);
			}
			
			hexPart += fullHex[i];
		}
		jsonMessageDump->set("hex", hexPart);

		//EBCDIC
		oss.str("");
		int row = 0;
		for(int i = 0; i < message.buffer().size(); ++i)
		{
			char ebcdic = EBCDIC_translate_ASCII[message.buffer()[i]];

			oss << (isprint((unsigned char) ebcdic) ? ebcdic : '.');
			if ( (i + 1) % 16 == 0 )
			{
				jsonMessageDump = jsonDump->getObject(row++);
				if ( !jsonMessageDump.isNull() )
				{
					jsonMessageDump->set("ebcdic", oss.str());
					oss.str("");
				}
			}
		}
		jsonMessageDump = jsonDump->getObject(row);
		if ( !jsonMessageDump.isNull() )
		{
			jsonMessageDump->set("ebcdic", htmlize(oss.str()));
			oss.str("");
		}

		//ASCII
		oss.str("");
		row = 0;
		for(int i = 0; i < message.buffer().size(); ++i)
		{
			oss << (isprint(message.buffer()[i]) ? (char) message.buffer()[i] : '.');
			if ( (i + 1) % 16 == 0 )
			{
				jsonMessageDump = jsonDump->getObject(row++);
				if ( !jsonMessageDump.isNull() )
				{
					jsonMessageDump->set("ascii", oss.str());
					oss.str("");
				}
			}
		}
		jsonMessageDump = jsonDump->getObject(row);
		if ( !jsonMessageDump.isNull() )
		{
			jsonMessageDump->set("ascii", htmlize(oss.str()));
			oss.str("");
		}

		jsonMessage->set("id", messageId);
	}
	else if ( type.compare("detail") == 0 )
	{
		jsonMessage->set("id", messageId);
	}

	_data->set("message", jsonMessage);

	tpl = Poco::JSON::TemplateCache::instance()->getTemplate(Poco::Path("message.tpl"));
	if ( ! tpl.isNull() )
	{
		// Don't cache the result
		_response.set("Cache-Control", "no-cache,no-store,must-revalidate");
		_response.set("Pragma", "no-cache");
		_response.set("Expires", "0");
		tpl->render(_data, _response.send());
		_response.setStatus(Poco::Net::HTTPResponse::HTTP_OK);
		return;
	}

	_response.setStatus(Poco::Net::HTTPResponse::HTTP_REASON_BAD_REQUEST);
}

} } // Namespace MQ::Web
